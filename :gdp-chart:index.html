<html>
  <head>
    <style>
      .node circle {
        stroke: #3a403d;
        stroke-width: 0.5px;
      }
    </style>
  </head>
  <body>
    <h2
      style="text-align: center; font-family: sans-serif; margin-bottom: 10px"
    >
      Verdens befolkning fordelt på regioner
    </h2>

    <div id="my_dataviz"></div>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
      var width = window.innerWidth,
        height = window.innerHeight,
        sizeDivisor = 100,
        nodePadding = 2.5;

      var svg = d3
        .select("body")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      var color = d3.scaleOrdinal([
        "#2a2ae0", // mørk blå
        "#4444FF", // original blå
        "#6a6aff", // lysere blå
        "#a5a5ff", // pastelblå

        "#cc7c1e", // mørk orange
        "#F99D40", // original orange
        "#fab56d", // lysere orange
        "#ffe1c2", // meget lys orange / pastel
      ]);

      var simulation = d3
        .forceSimulation()
        .force(
          "forceX",
          d3
            .forceX()
            .strength(0.1)
            .x(width * 0.5)
        )
        .force(
          "forceY",
          d3
            .forceY()
            .strength(0.1)
            .y(height * 0.5)
        )
        .force(
          "center",
          d3
            .forceCenter()
            .x(width * 0.5)
            .y(height * 0.5)
        )
        .force("charge", d3.forceManyBody().strength(-15));

      d3.csv("data.csv", types, function (error, graph) {
        if (error) throw error;

        // sort the nodes so that the bigger ones are at the back
        graph = graph.sort(function (a, b) {
          return b.size - a.size;
        });

        //update the simulation based on the data
        simulation
          .nodes(graph)
          .force(
            "collide",
            d3
              .forceCollide()
              .strength(0.5)
              .radius(function (d) {
                return d.radius + nodePadding;
              })
              .iterations(1)
          )
          .on("tick", function (d) {
            node
              .attr("cx", function (d) {
                return d.x;
              })
              .attr("cy", function (d) {
                return d.y;
              });
          });

        var node = svg
          .append("g")
          .attr("class", "node")
          .selectAll("circle")
          .data(graph)
          .enter()
          .append("circle")
          .attr("r", function (d) {
            return d.radius;
          })
          .attr("fill", function (d) {
            return color(d.continent);
          })
          .attr("cx", function (d) {
            return d.x;
          })
          .attr("cy", function (d) {
            return d.y;
          })
          .call(
            d3
              .drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended)
          );
      });
      // create a tooltip
      var Tooltip = d3
        .select("#my_dataviz")
        .append("div")
        .style("opacity", 0)
        .attr("class", "tooltip")
        .style("background-color", "white")
        .style("border", "solid")
        .style("border-width", "2px")
        .style("border-radius", "5px")
        .style("padding", "5px");

      // Three function that change the tooltip when user hover / move / leave a cell
      var mouseover = function (d) {
        Tooltip.style("opacity", 1);
      };
      var mousemove = function (d) {
        Tooltip.html("<u>" + d.key + "</u>" + "<br>" + d.value + " inhabitants")
          .style("left", d3.mouse(this)[0] + 20 + "px")
          .style("top", d3.mouse(this)[1] + "px");
      };
      var mouseleave = function (d) {
        Tooltip.style("opacity", 0);
      };
      function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.03).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
      }

      function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0.03);
        d.fx = null;
        d.fy = null;
      }

      function types(d) {
        d.gdp = +d.gdp;
        d.size = +d.gdp / sizeDivisor;
        d.size < 3 ? (d.radius = 3) : (d.radius = d.size);
        return d;
      }
    </script>
  </body>
</html>
